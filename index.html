<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>3Dè™šæ‹Ÿå±•å…</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(to bottom, #87CEEB, #e6f7ff);
            cursor: none;
        }

        canvas {
            display: block;
        }

        .info {
            position: fixed;
            top: 10px;
            left: 10px;
            color: #333;
            font-family: Arial, sans-serif;
            font-size: 14px;
            background: rgba(255,255,255,0.9);
            padding: 12px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            max-width: 320px;
            z-index: 100;
        }

            .info p {
                margin: 4px 0;
            }

            .info .title {
                font-weight: bold;
                margin-bottom: 6px;
                color: #2c3e50;
            }

            .info .highlight {
                color: #e74c3c;
                font-weight: bold;
            }

            .info .perspective {
                color: #3498db;
                font-weight: bold;
            }

        .cursor-dot {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 8px;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 0 6px rgba(0,0,0,0.8);
            border: 1px solid rgba(0, 0, 0, 0.3);
            display: none;
        }

        .click-to-start {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 30px;
            border-radius: 8px;
            font-family: Arial, sans-serif;
            font-size: 16px;
            z-index: 1001;
            cursor: pointer;
            text-align: center;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.2);
        }

            .click-to-start:hover {
                background-color: rgba(30, 30, 30, 0.9);
            }

        .perspective-indicator {
            position: fixed;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            z-index: 100;
            box-shadow: 0 0 8px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2);
        }

        /* æ–°å¢ï¼šéŸ³ä¹æŒ‡ç¤ºå™¨æ ·å¼ */
        .music-indicator {
            position: fixed;
            top: 50px; /* åœ¨è§†è§’æŒ‡ç¤ºå™¨ä¸‹é¢ */
            right: 10px;
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-family: Arial, sans-serif;
            font-size: 12px;
            z-index: 100;
            box-shadow: 0 0 8px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2);
            cursor: default; /* æ”¹ä¸ºé»˜è®¤ï¼Œè¡¨ç¤ºä¸å¯ç‚¹å‡» */
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            max-width: 300px;
        }

            .music-indicator:hover {
                background-color: rgba(0, 0, 0, 0.9); /* ç§»é™¤æ‚¬åœæ•ˆæœ */
                transform: none; /* ç§»é™¤æ‚¬åœæ•ˆæœ */
                box-shadow: 0 0 8px rgba(0,0,0,0.3); /* ç§»é™¤æ‚¬åœæ•ˆæœ */
            }

        .music-icon {
            margin-right: 8px;
            font-size: 14px;
        }

        .music-playing {
            color: #4CAF50;
        }

        .music-paused {
            color: #ff9800;
        }

        .music-name {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 200px;
        }

        /* æ–°å¢ï¼šå±•å“ä»‹ç»æ ·å¼ */
        .exhibit-info {
            position: fixed;
            top: 50%;
            right: 20px; /* æ”¹ä¸ºå›ºå®šåœ¨å³ä¾§ï¼Œè·ç¦»å³è¾¹20px */
            transform: translateY(-50%); /* åªå‚ç›´å±…ä¸­ */
            background-color: rgba(0, 0, 0, 0.8); /* 80%ä¸é€æ˜åº¦ */
            color: white;
            padding: 20px;
            border-radius: 10px;
            font-family: Arial, sans-serif;
            font-size: 16px;
            width: 380px; /* å›ºå®šå®½åº¦ */
            max-height: 400px; /* å¢åŠ æœ€å¤§é«˜åº¦ */
            overflow-y: auto;
            z-index: 1002;
            box-shadow: 0 0 20px rgba(0,0,0,0.7);
            border: 2px solid rgba(255,255,255,0.2);
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

            .exhibit-info.show {
                opacity: 1;
                pointer-events: auto;
            }

        .exhibit-info-name {
            font-size: 22px;
            font-weight: bold;
            margin-bottom: 12px;
            color: #ff8c00; /* æ©™è‰²ï¼Œç±»ä¼¼#ffa500ä½†æ›´é²œæ˜ */
            text-align: center;
            padding-bottom: 8px;
            border-bottom: 2px solid rgba(255, 140, 0, 0.3);
            text-shadow: 0 0 5px rgba(255, 140, 0, 0.3);
        }

        .exhibit-info-content {
            line-height: 1.6;
            text-align: justify;
            font-size: 15px;
            color: #f0f0f0;
        }

        /* è‡ªå®šä¹‰æ»šåŠ¨æ¡ */
        .exhibit-info::-webkit-scrollbar {
            width: 8px;
        }

        .exhibit-info::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        .exhibit-info::-webkit-scrollbar-thumb {
            background: rgba(255, 140, 0, 0.5);
            border-radius: 4px;
        }

            .exhibit-info::-webkit-scrollbar-thumb:hover {
                background: rgba(255, 140, 0, 0.7);
            }
    </style>
</head>
<body>
    <div class="info">
        <p class="title">ğŸ® 3Dè™šæ‹Ÿå±•å…æ“ä½œè¯´æ˜</p>
        <p>â€¢ <span class="highlight">WASDé”®</span> - æ§åˆ¶ç©å®¶ç§»åŠ¨</p>
        <p>â€¢ <span class="highlight">é¼ æ ‡ç§»åŠ¨</span> - æ—‹è½¬è§†è§’</p>
        <p>â€¢ <span class="highlight">ç©ºæ ¼é”®</span> - ç©å®¶ä¸Šå‡ | <span class="highlight">Shifté”®</span> - ç©å®¶ä¸‹é™</p>
        <p>â€¢ <span class="highlight">Vé”®</span> - <span class="perspective">åˆ‡æ¢ç¬¬ä¸€äººç§°/ç¬¬ä¸‰äººç§°è§†è§’</span></p>
        <p>â€¢ <span class="highlight">Mé”®</span> - æš‚åœ/æ’­æ”¾èƒŒæ™¯éŸ³ä¹</p>
        <p>â€¢ <span class="highlight">ESCé”®</span> - é€€å‡ºé¼ æ ‡é”å®šæ¨¡å¼</p>
        <p>â€¢ <span class="highlight">å±•å“ä»‹ç»</span>ï¼šç¬¬ä¸€äººç§°è§†è§’ä¸‹ï¼Œå‡†æ˜Ÿå¯¹å‡†å±•å“æ—¶æ˜¾ç¤ºä»‹ç»</p>
        <p>â€¢ <span class="highlight">èƒŒæ™¯éŸ³ä¹</span>ï¼šç‚¹å‡»"å¼€å§‹æ§åˆ¶"åè‡ªåŠ¨æ’­æ”¾ï¼ŒæŒ‰Mé”®æ§åˆ¶æ’­æ”¾/æš‚åœ</p>
    </div>

    <div class="cursor-dot" id="cursorDot"></div>
    <div class="click-to-start" id="clickToStart">ç‚¹å‡»æ­¤å¤„å¼€å§‹æ§åˆ¶</div>
    <div class="perspective-indicator" id="perspectiveIndicator">ç¬¬ä¸€äººç§°è§†è§’</div>

    <!-- æ–°å¢ï¼šéŸ³ä¹æŒ‡ç¤ºå™¨ -->
    <div class="music-indicator" id="musicIndicator">
        <span class="music-icon" id="musicIcon">â–¶ï¸</span>
        <span class="music-name" id="musicName">åŠ è½½ä¸­...</span>
    </div>

    <!-- æ–°å¢ï¼šå±•å“ä»‹ç»å®¹å™¨ -->
    <div class="exhibit-info" id="exhibitInfo">
        <div class="exhibit-info-name" id="exhibitInfoName">å±•å“åç§°</div>
        <div class="exhibit-info-content" id="exhibitInfoContent">å±•å“ä»‹ç»å†…å®¹</div>
    </div>

    <!-- å¼•å…¥ç¨³å®šThree.jsåŠGLTFåŠ è½½å™¨CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // ========== æ–°å¢ï¼šèƒŒæ™¯éŸ³ä¹ç³»ç»Ÿ ==========
        const musicFolder = `${baseUrl}/music`; // éŸ³ä¹å¤–é“¾è·¯å¾„
        let backgroundMusic = null;
        let isMusicPlaying = false;
        let currentMusicIndex = 0;
        let musicFiles = [
            "ç¯ç«é‡Œçš„ä¸­å›½ é’¢ç´ç‰ˆ.mp3"
        ]; // å­˜å‚¨éŸ³ä¹æ–‡ä»¶åˆ—è¡¨

        // éŸ³ä¹æŒ‡ç¤ºå™¨å…ƒç´ 
        const musicIndicator = document.getElementById('musicIndicator');
        const musicIcon = document.getElementById('musicIcon');
        const musicName = document.getElementById('musicName');

        // åˆå§‹åŒ–èƒŒæ™¯éŸ³ä¹ç³»ç»Ÿ
        function initBackgroundMusic() {
            console.log("ğŸµ åˆå§‹åŒ–èƒŒæ™¯éŸ³ä¹ç³»ç»Ÿ...");

            // åˆ›å»ºéŸ³é¢‘ä¸Šä¸‹æ–‡ï¼ˆå…¼å®¹æ€§å¤„ç†ï¼‰
            try {
                // åˆ›å»ºAudioå¯¹è±¡
                backgroundMusic = new Audio();
                backgroundMusic.loop = true; // å¾ªç¯æ’­æ”¾
                backgroundMusic.volume = 0.5; // éŸ³é‡è®¾ä¸º100%

                // å°è¯•åŠ è½½éŸ³ä¹æ–‡ä»¶åˆ—è¡¨
                loadMusicFiles();

                // è®¾ç½®éŸ³ä¹æ’­æ”¾çŠ¶æ€æ›´æ–°
                backgroundMusic.addEventListener('play', () => {
                    updateMusicUI(true);
                });

                backgroundMusic.addEventListener('pause', () => {
                    updateMusicUI(false);
                });

                backgroundMusic.addEventListener('ended', () => {
                    playNextMusic();
                });

                // ä¸å†ç‚¹å‡»éŸ³ä¹æŒ‡ç¤ºå™¨åˆ‡æ¢æ’­æ”¾çŠ¶æ€
                //musicIndicator.addEventListener('click', toggleMusicPlayback);

                // é¡µé¢åŠ è½½åè‡ªåŠ¨æ’­æ”¾éŸ³ä¹ï¼ˆéœ€è¦ç”¨æˆ·äº¤äº’ï¼Œæ‰€ä»¥æ”¾åœ¨ç‚¹å‡»å¼€å§‹äº‹ä»¶ä¸­ï¼‰
                console.log("âœ… èƒŒæ™¯éŸ³ä¹ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ");
            } catch (error) {
                console.error("âŒ èƒŒæ™¯éŸ³ä¹åˆå§‹åŒ–å¤±è´¥:", error);
                musicName.textContent = "éŸ³ä¹æ’­æ”¾å™¨åˆå§‹åŒ–å¤±è´¥";
                musicIndicator.style.display = 'none'; // éšè—éŸ³ä¹æŒ‡ç¤ºå™¨
            }
        }

        // åŠ è½½éŸ³ä¹æ–‡ä»¶åˆ—è¡¨
        function loadMusicFiles() {
            // è¿™é‡Œæ˜¯ç¡¬ç¼–ç çš„éŸ³ä¹æ–‡ä»¶åˆ—è¡¨
            // ä½ å¯ä»¥å°†éŸ³ä¹æ–‡ä»¶æ”¾åœ¨musicæ–‡ä»¶å¤¹ä¸­ï¼Œå¹¶åœ¨è¿™é‡Œæ·»åŠ æ–‡ä»¶å
            musicFiles = [
                "ç¯ç«é‡Œçš„ä¸­å›½ é’¢ç´ç‰ˆ.mp3"
            ];

            console.log(`ğŸµ å‘ç° ${musicFiles.length} ä¸ªéŸ³ä¹æ–‡ä»¶`);

            // å°è¯•æ’­æ”¾ç¬¬ä¸€ä¸ªéŸ³ä¹æ–‡ä»¶
            if (musicFiles.length > 0) {
                playMusicByIndex(0);
            } else {
                musicName.textContent = "æœªæ‰¾åˆ°éŸ³ä¹æ–‡ä»¶";
                musicIcon.style.display = 'none';
            }
        }

        // æŒ‰ç´¢å¼•æ’­æ”¾éŸ³ä¹
        function playMusicByIndex(index) {
            if (!backgroundMusic || index < 0 || index >= musicFiles.length) return;

            currentMusicIndex = index;
            const musicFile = musicFiles[index];
            const musicPath = `${musicFolder}/${musicFile}`;

            console.log(`ğŸµ å°è¯•æ’­æ”¾: ${musicPath}`);

            // è®¾ç½®éŸ³ä¹æº
            backgroundMusic.src = musicPath;

            // å°è¯•æ’­æ”¾ï¼ˆéœ€è¦ç”¨æˆ·äº¤äº’ï¼‰
            if (isMusicPlaying) {
                backgroundMusic.play().catch(error => {
                    console.log("âš ï¸ è‡ªåŠ¨æ’­æ”¾è¢«é˜»æ­¢ï¼Œéœ€è¦ç”¨æˆ·äº¤äº’:", error);
                    musicName.textContent = "ç‚¹å‡»æ’­æ”¾éŸ³ä¹";
                    musicIcon.textContent = "â¸ï¸";
                });
            }

            // æ›´æ–°UIæ˜¾ç¤ºéŸ³ä¹åï¼ˆå»æ‰æ‰©å±•åï¼‰
            const displayName = musicFile.replace(/\.[^/.]+$/, "").replace(/_/g, " ");
            musicName.textContent = displayName;
        }

        // æ’­æ”¾ä¸‹ä¸€é¦–éŸ³ä¹
        function playNextMusic() {
            if (musicFiles.length === 0) return;

            currentMusicIndex = (currentMusicIndex + 1) % musicFiles.length;
            playMusicByIndex(currentMusicIndex);

            // å¦‚æœä¹‹å‰æ­£åœ¨æ’­æ”¾ï¼Œç»§ç»­æ’­æ”¾
            if (isMusicPlaying) {
                backgroundMusic.play().catch(error => {
                    console.log("åˆ‡æ¢éŸ³ä¹åæ’­æ”¾å¤±è´¥:", error);
                });
            }
        }

        // åˆ‡æ¢éŸ³ä¹æ’­æ”¾çŠ¶æ€
        function toggleMusicPlayback() {
            if (!backgroundMusic) return;

            if (isMusicPlaying) {
                backgroundMusic.pause();
                isMusicPlaying = false;
            } else {
                backgroundMusic.play().then(() => {
                    isMusicPlaying = true;
                }).catch(error => {
                    console.log("æ’­æ”¾å¤±è´¥:", error);
                    // å¦‚æœæ’­æ”¾å¤±è´¥ï¼Œæç¤ºç”¨æˆ·ç‚¹å‡»å¼€å§‹æ§åˆ¶
                    musicName.textContent = "ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å¼€å§‹";
                });
            }
        }

        // å¼€å§‹æ’­æ”¾éŸ³ä¹ï¼ˆåœ¨ç”¨æˆ·äº¤äº’åè°ƒç”¨ï¼‰
        function startMusicPlayback() {
            if (!backgroundMusic || musicFiles.length === 0) return;

            backgroundMusic.play().then(() => {
                isMusicPlaying = true;
                console.log("ğŸµ èƒŒæ™¯éŸ³ä¹å¼€å§‹æ’­æ”¾");
            }).catch(error => {
                console.log("âš ï¸ è‡ªåŠ¨æ’­æ”¾è¢«é˜»æ­¢:", error);
                musicName.textContent = "ç‚¹å‡»æ­¤å¤„æ’­æ”¾éŸ³ä¹";
                musicIcon.textContent = "â–¶ï¸";
            });
        }

        // æ›´æ–°éŸ³ä¹UIçŠ¶æ€
        function updateMusicUI(playing) {
            isMusicPlaying = playing;

            if (playing) {
                musicIcon.textContent = "ğŸµ";
                musicIcon.className = "music-icon music-playing";
                musicIndicator.title = "ç‚¹å‡»æš‚åœéŸ³ä¹";
            } else {
                musicIcon.textContent = "â¸ï¸";
                musicIcon.className = "music-icon music-paused";
                musicIndicator.title = "ç‚¹å‡»æ’­æ”¾éŸ³ä¹";
            }
        }

        // ========== 1. åœºæ™¯æ ¸å¿ƒåˆå§‹åŒ– ==========
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xe6f7ff);

        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 1.5, 5);

        // ä¿®æ”¹ï¼šé™ä½æ¸²æŸ“è´¨é‡ä»¥æé«˜æ€§èƒ½
        const renderer = new THREE.WebGLRenderer({
            antialias: false, // å…³é—­æŠ—é”¯é½¿
            alpha: false,
            precision: 'lowp' // ä½¿ç”¨ä½ç²¾åº¦
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(1.0); // å›ºå®šåƒç´ æ¯”ä¸º1.0ï¼Œè¿›ä¸€æ­¥é™ä½è´¨é‡
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        const rendererCanvas = renderer.domElement;
        document.body.appendChild(rendererCanvas);

        // ========== 2. è§†è§’æ¨¡å¼æ§åˆ¶ ==========
        let perspectiveMode = "first";
        const perspectiveIndicator = document.getElementById('perspectiveIndicator');

        // Vé”®åˆ‡æ¢è§†è§’
        document.addEventListener('keydown', (e) => {
            if (e.key === ' ') e.preventDefault();

            switch (e.key.toLowerCase()) {
                case 'w': keyStates.w = true; break;
                case 'a': keyStates.a = true; break;
                case 's': keyStates.s = true; break;
                case 'd': keyStates.d = true; break;
                case ' ': keyStates.space = true; break;
                case 'shift': keyStates.shift = true; break;
                case 'm': toggleMusicPlayback(); break;
                case 'v': // æ·»åŠ Vé”®åˆ‡æ¢è§†è§’
                    if (perspectiveMode === "first") {
                        perspectiveMode = "third";
                        perspectiveIndicator.textContent = "ç¬¬ä¸‰äººç§°è§†è§’";
                    } else {
                        perspectiveMode = "first";
                        perspectiveIndicator.textContent = "ç¬¬ä¸€äººç§°è§†è§’";
                    }
                    break;
            }
        });

        // ========== 3. é¼ æ ‡é”å®šæ§åˆ¶ ==========
        let isMouseLocked = false;
        const cursorDot = document.getElementById('cursorDot');
        const clickToStart = document.getElementById('clickToStart');

        clickToStart.style.display = 'block';

        clickToStart.addEventListener('click', () => {
            requestPointerLock();

            // ç”¨æˆ·ç‚¹å‡»å¼€å§‹åï¼Œå¯åŠ¨èƒŒæ™¯éŸ³ä¹æ’­æ”¾
            startMusicPlayback();
        });

        rendererCanvas.addEventListener('click', () => {
            if (!isMouseLocked) {
                requestPointerLock();

                // ç”¨æˆ·ç‚¹å‡»åå¯åŠ¨éŸ³ä¹æ’­æ”¾
                startMusicPlayback();
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                exitPointerLock();
            }
        });

        function requestPointerLock() {
            rendererCanvas.requestPointerLock = rendererCanvas.requestPointerLock ||
                rendererCanvas.mozRequestPointerLock ||
                rendererCanvas.webkitRequestPointerLock;
            rendererCanvas.requestPointerLock();
        }

        function exitPointerLock() {
            document.exitPointerLock = document.exitPointerLock ||
                document.mozExitPointerLock ||
                document.webkitExitPointerLock;
            document.exitPointerLock();
        }

        document.addEventListener('pointerlockchange', pointerLockChange, false);
        document.addEventListener('mozpointerlockchange', pointerLockChange, false);
        document.addEventListener('webkitpointerlockchange', pointerLockChange, false);

        function pointerLockChange() {
            if (document.pointerLockElement === rendererCanvas ||
                document.mozPointerLockElement === rendererCanvas ||
                document.webkitPointerLockElement === rendererCanvas) {
                isMouseLocked = true;
                cursorDot.style.display = 'block';
                clickToStart.style.display = 'none';
            } else {
                isMouseLocked = false;
                cursorDot.style.display = 'none';
                clickToStart.style.display = 'block';
            }
        }

        // ========== 4. ç›¸æœºæ§åˆ¶ç³»ç»Ÿ ==========
        let targetRotationX = Math.PI;
        let targetRotationY = 0;
        let currentRotationX = Math.PI;
        let currentRotationY = 0;

        const cameraDistance = 8;
        const cameraHeight = 1;
        const firstPersonHeight = 1.5;
        const sensitivity = 0.002;

        // é¼ æ ‡ç§»åŠ¨äº‹ä»¶
        document.addEventListener('mousemove', (e) => {
            if (!isMouseLocked) return;

            const movementX = e.movementX || e.mozMovementX || e.webkitMovementX || 0;
            const movementY = e.movementY || e.mozMovementY || e.webkitMovementY || 0;

            // æ˜ å°„ï¼š
            targetRotationX -= movementX * sensitivity;
            targetRotationY += movementY * sensitivity;

            targetRotationY = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, targetRotationY));
        });

        // ========== 5. ç©å®¶å¯¹è±¡==========
        const player = new THREE.Object3D();
        player.position.set(0, 0.5, 0);
        scene.add(player);

        // äººç‰©æ¨¡å‹åŠ è½½å™¨
        const characterLoader = new THREE.GLTFLoader();
        let characterModel = null;

        // åŠ è½½äººç‰©æ¨¡å‹
        characterLoader.load(
            '3d_models/character.glb', // äººç‰©æ¨¡å‹æ–‡ä»¶è·¯å¾„
            (gltf) => {
                characterModel = gltf.scene;

                // è®¾ç½®äººç‰©æ¨¡å‹
                characterModel.scale.set(2, 2, 2);
                characterModel.position.y = -0.3;
                characterModel.rotation.y = Math.PI;

                characterModel.traverse((child) => {
                    if (child.isMesh) {
                        // ç¦ç”¨äººç‰©æ¨¡å‹é˜´å½±ä»¥æå‡æ€§èƒ½
                        child.castShadow = false;
                        child.receiveShadow = false;

                        // ä¸ºäººç‰©æ¨¡å‹æ·»åŠ è‡ªå‘å…‰æ•ˆæœ
                        if (child.material) {
                            // å…‹éš†æè´¨é¿å…å½±å“å…¶ä»–ç‰©ä½“
                            const material = child.material.clone();

                            // è®¾ç½®è‡ªå‘å…‰é¢œè‰²å’Œå¼ºåº¦
                            material.emissive = new THREE.Color(0x333333); // ç°è‰²è‡ªå‘å…‰
                            material.emissiveIntensity = 0.3; // è‡ªå‘å…‰å¼ºåº¦ï¼Œè°ƒæ•´è¿™ä¸ªå€¼æ§åˆ¶äº®åº¦

                            // å¢åŠ æè´¨æœ¬èº«çš„äº®åº¦
                            if (material.color) {
                                const originalColor = material.color.clone();
                                const brighterColor = originalColor.multiplyScalar(1.5); // æé«˜1.5å€äº®åº¦
                                material.color = brighterColor;
                            }

                            child.material = material;
                        }
                    }
                });

                // æ·»åŠ åˆ°ç©å®¶å¯¹è±¡
                player.add(characterModel);
                console.log("âœ… äººç‰©æ¨¡å‹åŠ è½½æˆåŠŸï¼Œå·²åº”ç”¨ä¼˜åŒ–è®¾ç½®");
            },
            (xhr) => {
                console.log(`äººç‰©æ¨¡å‹åŠ è½½è¿›åº¦ï¼š${Math.round((xhr.loaded / xhr.total) * 100)}%`);
            },
            (error) => {
                console.log("âŒ äººç‰©æ¨¡å‹åŠ è½½å¤±è´¥ (è·¯å¾„: 3d_models/character.glb)ï¼Œä½¿ç”¨é»˜è®¤æ–¹å—", error);
                // ä½¿ç”¨é»˜è®¤æ–¹å—ä½œä¸ºå›é€€
                const playerGeo = new THREE.BoxGeometry(0.8, 1.8, 0.8);
                const playerMat = new THREE.MeshStandardMaterial({
                    color: 0xff4444,
                    metalness: 0.1,
                    roughness: 0.7,
                    // ä¸ºå›é€€æ–¹å—æ·»åŠ è‡ªå‘å…‰
                    emissive: 0x333333,
                    emissiveIntensity: 0.3
                });
                characterModel = new THREE.Mesh(playerGeo, playerMat);
                // ä¿®æ”¹1: è°ƒæ•´å›é€€æ–¹å—é«˜åº¦ï¼Œä»0.9æ”¹ä¸º1.1
                characterModel.position.y = 1.1;
                // æ·»åŠ æ—‹è½¬180åº¦
                characterModel.rotation.y = Math.PI;
                // ä¿®æ”¹3: ç¦ç”¨é˜´å½±ä»¥æå‡æ€§èƒ½
                characterModel.castShadow = false;
                player.add(characterModel);
            }
        );

        // ç¬¬ä¸€äººç§°è§†è§’ä¸‹çš„æ‰‹æŒç‰©ä½“
        const firstPersonHand = new THREE.Mesh(
            new THREE.BoxGeometry(0.3, 0.3, 0.6),
            new THREE.MeshBasicMaterial({ color: 0x333333 })
        );
        firstPersonHand.position.set(0.3, -0.2, -0.5);
        firstPersonHand.visible = false;
        camera.add(firstPersonHand);

        // ========== 6. WASDç§»åŠ¨æ§åˆ¶ - ä¿®æ­£ç§»åŠ¨æ–¹å‘ ==========
        const keyStates = {
            w: false, a: false, s: false, d: false,
            space: false, shift: false
        };

        document.addEventListener('keydown', (e) => {
            if (e.key === ' ') e.preventDefault();

            switch (e.key.toLowerCase()) {
                case 'w': keyStates.w = true; break;
                case 'a': keyStates.a = true; break;
                case 's': keyStates.s = true; break;
                case 'd': keyStates.d = true; break;
                case ' ': keyStates.space = true; break;
                case 'shift': keyStates.shift = true; break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch (e.key.toLowerCase()) {
                case 'w': keyStates.w = false; break;
                case 'a': keyStates.a = false; break;
                case 's': keyStates.s = false; break;
                case 'd': keyStates.d = false; break;
                case ' ': keyStates.space = false; break;
                case 'shift': keyStates.shift = false; break;
            }
        });

        const moveSpeed = 0.18;
        const verticalSpeed = 0.15;

        const groundBounds = {
            minX: -50,
            maxX: 50,
            minZ: -50,
            maxZ: 50,
            minY: 0.5,
            maxY: 20
        };

        // ç§»åŠ¨é€»è¾‘ - ä¿®æ­£forward/rightå‘é‡ï¼ˆæ ¸å¿ƒä¿®å¤ç§»åŠ¨æ–¹å‘ï¼‰
        function updatePlayerMovement() {
            // æœ€ç»ˆæ­£ç¡®çš„æ–¹å‘å‘é‡ï¼šWå‰è¿›ã€Såé€€ã€Aå·¦ç§»ã€Då³ç§»
            const forward = new THREE.Vector3(
                Math.sin(currentRotationX),
                0,
                Math.cos(currentRotationX)
            ).normalize();

            const right = new THREE.Vector3(
                -Math.cos(currentRotationX),
                0,
                Math.sin(currentRotationX)
            ).normalize();

            const moveVec = new THREE.Vector3(0, 0, 0);

            if (keyStates.w) moveVec.add(forward);
            if (keyStates.s) moveVec.sub(forward);
            if (keyStates.d) moveVec.add(right);
            if (keyStates.a) moveVec.sub(right);

            if (moveVec.length() > 0) {
                moveVec.normalize();
                player.position.add(moveVec.multiplyScalar(moveSpeed));
            }

            player.position.x = Math.max(groundBounds.minX, Math.min(groundBounds.maxX, player.position.x));
            player.position.z = Math.max(groundBounds.minZ, Math.min(groundBounds.maxZ, player.position.z));

            if (keyStates.space) player.position.y += verticalSpeed;
            if (keyStates.shift) player.position.y -= verticalSpeed;

            player.position.y = Math.max(groundBounds.minY, Math.min(groundBounds.maxY, player.position.y));
        }

        // ========== 7. ç›¸æœºæ›´æ–°å‡½æ•° - ä¿®æ­£ä¸Šä¸‹è§†è§’ ==========
        function updateCamera() {
            currentRotationX += (targetRotationX - currentRotationX) * 0.1;
            currentRotationY += (targetRotationY - currentRotationY) * 0.1;

            if (perspectiveMode === "first") {
                // ç¬¬ä¸€äººç§°è§†è§’
                const cameraX = player.position.x;
                const cameraY = player.position.y + firstPersonHeight;
                const cameraZ = player.position.z;

                camera.position.set(cameraX, cameraY, cameraZ);

                // é¼ æ ‡å³â†’è§†è§’å³ï¼Œé¼ æ ‡ä¸Šâ†’è§†è§’ä¸Š
                const lookX = cameraX + Math.sin(currentRotationX) * Math.cos(currentRotationY);
                const lookY = cameraY - Math.sin(currentRotationY);
                const lookZ = cameraZ + Math.cos(currentRotationX) * Math.cos(currentRotationY);

                camera.lookAt(lookX, lookY, lookZ);

                firstPersonHand.visible = true;

                // ç¬¬ä¸€äººç§°éšè—äººç‰©æ¨¡å‹
                if (characterModel) {
                    characterModel.visible = false;
                }
            } else {
                // ç¬¬ä¸‰äººç§°è§†è§’
                const cameraX = player.position.x - Math.sin(currentRotationX) * cameraDistance * Math.cos(currentRotationY);
                const cameraY = player.position.y + cameraHeight + Math.sin(currentRotationY) * cameraDistance;
                const cameraZ = player.position.z - Math.cos(currentRotationX) * cameraDistance * Math.cos(currentRotationY);

                camera.position.set(cameraX, cameraY, cameraZ);
                camera.lookAt(player.position.x, player.position.y + 1, player.position.z);

                firstPersonHand.visible = false;

                // ç¬¬ä¸‰äººç§°æ˜¾ç¤ºäººç‰©æ¨¡å‹
                if (characterModel) {
                    characterModel.visible = true;

                    // æ–°å¢ï¼šè®©äººç‰©æ¨¡å‹å§‹ç»ˆæœå‘è§†è§’æ­£å‰æ–¹
                    // è®¡ç®—ç›®æ ‡æ—‹è½¬è§’åº¦ï¼ˆå¿½ç•¥å‚ç›´è§†è§’ï¼Œåªä½¿ç”¨æ°´å¹³è§†è§’ï¼‰
                    const targetRotation = currentRotationX;
                    const currentRotation = characterModel.rotation.y;
                    const smoothFactor = 0.1; // å¹³æ»‘ç³»æ•°ï¼Œå¯ä»¥è°ƒæ•´æ—‹è½¬é€Ÿåº¦

                    // è®¡ç®—è§’åº¦å·®å¹¶å¤„ç†360åº¦ç¯ç»•
                    let angleDiff = targetRotation - currentRotation;
                    if (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    if (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

                    // åº”ç”¨å¹³æ»‘æ—‹è½¬
                    characterModel.rotation.y += angleDiff * smoothFactor;
                }
            }
        }

        // ========== 8. è™šæ‹Ÿå±•å…æ­å»º ==========
        const groundConfig = {
            length: 100,
            width: 100,
            color: 0xf5f5f5
        };

        const floorGeo = new THREE.PlaneGeometry(groundConfig.length, groundConfig.width);
        const floorMat = new THREE.MeshStandardMaterial({
            color: groundConfig.color,
            roughness: 0.8,
            metalness: 0.05
        });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = 0;
        floor.receiveShadow = true;
        scene.add(floor);

        const gridHelper = new THREE.GridHelper(100, 100, 0xcccccc, 0xeeeeee);
        gridHelper.position.y = 0.01;
        scene.add(gridHelper);

        const boundaryLineMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
        const boundaryPoints = [];
        boundaryPoints.push(new THREE.Vector3(groundBounds.minX, 0.1, groundBounds.minZ));
        boundaryPoints.push(new THREE.Vector3(groundBounds.maxX, 0.1, groundBounds.minZ));
        boundaryPoints.push(new THREE.Vector3(groundBounds.maxX, 0.1, groundBounds.maxZ));
        boundaryPoints.push(new THREE.Vector3(groundBounds.minX, 0.1, groundBounds.maxZ));
        boundaryPoints.push(new THREE.Vector3(groundBounds.minX, 0.1, groundBounds.minZ));

        const boundaryGeometry = new THREE.BufferGeometry().setFromPoints(boundaryPoints);
        const boundaryLine = new THREE.Line(boundaryGeometry, boundaryLineMaterial);
        scene.add(boundaryLine);

        const cornerGeometry = new THREE.BoxGeometry(0.5, 1, 0.5);
        const cornerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });

        const cornerPositions = [
            { x: groundBounds.minX, z: groundBounds.minZ },
            { x: groundBounds.maxX, z: groundBounds.minZ },
            { x: groundBounds.maxX, z: groundBounds.maxZ },
            { x: groundBounds.minX, z: groundBounds.maxZ }
        ];

        cornerPositions.forEach(pos => {
            const corner = new THREE.Mesh(cornerGeometry, cornerMaterial);
            corner.position.set(pos.x, 0.5, pos.z);
            scene.add(corner);
        });

        // ========== 9. æ ¸å¿ƒï¼šå±•å“è®¾ç½®ï¼ˆåŒ…æ‹¬ä»‹ç»åŠŸèƒ½ï¼‰ ==========
        const totalExhibits = 20;
        const baseUrl = "https://t9xj34bm7.hn-bkt.clouddn.com/virtualhall";
        const modelFolder = `${baseUrl}/3d_models`; // æ¨¡å‹å¤–é“¾è·¯å¾„
        const introductionFolder = `${baseUrl}/introduction`; // ä»‹ç»æ–‡æœ¬å¤–é“¾è·¯å¾„
        const exhibitGapX = 18;
        const exhibitGapZ = 18;
        const modelScale = 3.0;
        const modelY = 2.0;

        // ç»Ÿä¸€çš„å€¾æ–œè§’åº¦ï¼ˆå¼§åº¦åˆ¶ï¼‰- çº¦-17åº¦
        const unifiedTiltAngle = -0.3;

        // æ¨¡å‹å¢å¼ºå‚æ•°ï¼ˆåªé’ˆå¯¹æ¨¡å‹ï¼‰
        const modelSelfIllumination = true;
        const modelEmissiveIntensity = 1.5; // è‡ªå‘å…‰å¼ºåº¦
        const modelBrightnessBoost = 5.0; // æ¨¡å‹æè´¨äº®åº¦æå‡å€æ•°

        const cols = 5;
        const rows = Math.ceil(totalExhibits / cols);
        const startX = -(cols - 1) * exhibitGapX / 2;
        const startZ = -(rows - 1) * exhibitGapZ / 2;

        const loader = new THREE.GLTFLoader();

        // è“è‰²æ–¹å—é…ç½®ï¼ˆä¿æŒåŸæ ·ï¼Œä¸å—å½±å“ï¼‰
        const exhibitGeo = new THREE.BoxGeometry(2.5, 3, 2.5);
        const exhibitMat = new THREE.MeshStandardMaterial({
            color: 0x4488ff,
            roughness: 0.6,
            metalness: 0.15
        });

        // åˆ›å»ºæ¨¡å‹å¢å¼ºå‡½æ•° - åªä¿®æ”¹æ¨¡å‹æœ¬èº«
        function enhanceModelOnly(model) {
            // éå†æ¨¡å‹çš„æ‰€æœ‰ç½‘æ ¼
            model.traverse((child) => {
                if (child.isMesh) {
                    // åªä¿®æ”¹æ¨¡å‹çš„æè´¨ï¼Œä¸å½±å“å…¶ä»–å±æ€§
                    const originalMaterial = child.material;

                    // æ£€æŸ¥æ˜¯å¦æ˜¯æ•°ç»„æè´¨ï¼ˆå¤šä¸ªæè´¨ï¼‰
                    if (Array.isArray(originalMaterial)) {
                        // å¤„ç†æè´¨æ•°ç»„
                        const enhancedMaterials = originalMaterial.map(mat => enhanceSingleMaterial(mat));
                        child.material = enhancedMaterials;
                    } else {
                        // å¤„ç†å•ä¸ªæè´¨
                        child.material = enhanceSingleMaterial(originalMaterial);
                    }

                    // ç¡®ä¿é˜´å½±è®¾ç½®ä¸å˜
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });

            return model;
        }

        // å¢å¼ºå•ä¸ªæè´¨ï¼ˆæ ¸å¿ƒå‡½æ•°ï¼‰
        function enhanceSingleMaterial(material) {
            // åˆ›å»ºæ–°æè´¨æˆ–ä¿®æ”¹ç°æœ‰æè´¨
            let enhancedMaterial;

            if (!material) {
                // å¦‚æœæ²¡æœ‰æè´¨ï¼Œåˆ›å»ºæ–°çš„æ˜äº®æè´¨
                enhancedMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    roughness: 0.3,
                    metalness: 0.1,
                    emissive: 0xffffff,
                    emissiveIntensity: modelSelfIllumination ? modelEmissiveIntensity : 0
                });
            } else {
                // å…‹éš†ç°æœ‰æè´¨ä»¥é¿å…å½±å“å…¶ä»–ç‰©ä½“
                enhancedMaterial = material.clone();

                // å¢åŠ æè´¨äº®åº¦
                if (enhancedMaterial.color) {
                    // å°†é¢œè‰²è°ƒäº®
                    const originalColor = enhancedMaterial.color.clone();
                    const brighterColor = originalColor.multiplyScalar(modelBrightnessBoost);
                    enhancedMaterial.color = brighterColor;
                }

                // å¢åŠ è‡ªå‘å…‰
                if (modelSelfIllumination) {
                    if (!enhancedMaterial.emissive) {
                        enhancedMaterial.emissive = enhancedMaterial.color
                            ? enhancedMaterial.color.clone().multiplyScalar(0.5) // ä½¿ç”¨åŸè‰²çš„50%ä½œä¸ºè‡ªå‘å…‰
                            : new THREE.Color(0x888888);
                    }
                    enhancedMaterial.emissiveIntensity = modelEmissiveIntensity;
                }

                // ä½¿è¡¨é¢æ›´å…‰æ»‘ï¼Œåå°„æ›´å¤šå…‰çº¿
                enhancedMaterial.roughness = Math.min(enhancedMaterial.roughness || 0.5, 0.3);
                enhancedMaterial.metalness = Math.max(enhancedMaterial.metalness || 0, 0.1);

                // ç¡®ä¿æè´¨æ›´æ–°
                enhancedMaterial.needsUpdate = true;
            }

            return enhancedMaterial;
        }

        // ä¸ºæ¨¡å‹æ·»åŠ ä¸“å±å…‰æºï¼ˆåªç…§äº®è¯¥æ¨¡å‹ï¼‰
        function addModelSpecificLights(model) {
            // è®¡ç®—æ¨¡å‹åŒ…å›´ç›’
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            const modelSize = Math.max(size.x, size.y, size.z);

            // 1. æ­£é¢ä¸»å…‰æº
            const frontDir = new THREE.Vector3(
                0, // Xæ–¹å‘ä¸å˜ï¼Œå› ä¸ºæ¨¡å‹Yè½´ä¸æ—‹è½¬
                0.3, // å›ºå®šé«˜åº¦
                1 // Zæ–¹å‘å‘å‰
            ).normalize();

            const frontLight = new THREE.PointLight(0xffffff, 4.0, modelSize * 3);
            frontLight.position.copy(center).add(frontDir.multiplyScalar(modelSize * 1.5));
            model.add(frontLight);

            // 2. é¡¶éƒ¨å…‰æº
            const topLight = new THREE.PointLight(0xffffff, 2.5, modelSize * 3);
            topLight.position.set(
                center.x,
                center.y + modelSize * 1.2,
                center.z
            );
            model.add(topLight);

            // 3. ä¾§è¡¥å…‰
            const sideLight = new THREE.PointLight(0xffffff, 1.5, modelSize * 2);
            sideLight.position.set(
                center.x - modelSize * 1.2, // å·¦ä¾§è¡¥å…‰
                center.y + modelSize * 0.5,
                center.z
            );
            model.add(sideLight);

            return model;
        }

        // æ–°å¢ï¼šå­˜å‚¨æ‰€æœ‰GLBæ¨¡å‹å¼•ç”¨çš„æ•°ç»„
        const glbModels = [];

        // æ–°å¢ï¼šåŠ è½½ä»‹ç»æ–‡æœ¬çš„å‡½æ•° - ä¿®æ”¹è·¯å¾„ä¸ºintroductionæ–‡ä»¶å¤¹
        function loadExhibitInfo(modelIndex) {
            return fetch(`${introductionFolder}/${modelIndex}.txt`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`æ— æ³•åŠ è½½ä»‹ç»æ–‡ä»¶: ${introductionFolder}/${modelIndex}.txt`);
                    }
                    return response.text();
                })
                .then(text => {
                    // è§£ææ–‡æœ¬ï¼šç¬¬ä¸€è¡Œä¸ºå±•å“åç§°ï¼Œå‰©ä¸‹çš„ä¸ºä»‹ç»å†…å®¹
                    const lines = text.split('\n').filter(line => line.trim() !== '');
                    let name = `å±•å“ ${modelIndex}`;
                    let content = "æš‚æ— è¯¦ç»†ä»‹ç»";

                    if (lines.length > 0) {
                        name = lines[0].trim(); // ç¬¬ä¸€è¡Œæ˜¯åç§°
                        if (lines.length > 1) {
                            // ä»ç¬¬äºŒè¡Œå¼€å§‹æ˜¯ä»‹ç»å†…å®¹
                            content = lines.slice(1).join('\n').trim();
                        }
                    }

                    return { name, content };
                })
                .catch(error => {
                    console.log(`å±•å“${modelIndex}çš„ä»‹ç»æ–‡ä»¶æœªæ‰¾åˆ°ï¼Œä½¿ç”¨é»˜è®¤ä»‹ç»`);
                    return {
                        name: `å±•å“ ${modelIndex}`,
                        content: `è¿™æ˜¯å±•å“${modelIndex}çš„é»˜è®¤ä»‹ç»ã€‚\n\nè¯¥å±•å“å±•ç¤ºäº†ç‹¬ç‰¹çš„3Dæ¨¡å‹ï¼Œå…·æœ‰ç²¾ç¾çš„ç»†èŠ‚å’Œè®¾è®¡ã€‚`
                    };
                });
        }

        // å¾ªç¯åˆ›å»ºå±•å“
        for (let i = 0; i < totalExhibits; i++) {
            const col = i % cols;
            const row = Math.floor(i / cols);
            const posX = startX + col * exhibitGapX;
            const posZ = startZ + row * exhibitGapZ;
            const modelIndex = i + 1;

            loader.load(
                `${modelFolder}/${modelIndex}.glb`,
                (gltf) => {
                    const model = gltf.scene;

                    // 1. ç»Ÿä¸€æ¨¡å‹å¤§å°
                    model.scale.setScalar(modelScale);

                    // 2. æ¨¡å‹ä½ç½®å’Œè§’åº¦ - ä½¿ç”¨ç»Ÿä¸€å€¾æ–œè§’åº¦
                    model.position.set(posX, modelY, posZ);

                    // è®¾ç½®æ¨¡å‹æ—‹è½¬ï¼šæ‰€æœ‰æ¨¡å‹ç»Ÿä¸€å€¾æ–œè§’åº¦
                    model.rotation.x = unifiedTiltAngle; // ç»Ÿä¸€å€¾æ–œè§’åº¦
                    model.rotation.y = 0; // Yè½´ä¸æ—‹è½¬

                    // 3. åªå¢å¼ºæ¨¡å‹æœ¬èº«äº®åº¦
                    enhanceModelOnly(model);

                    // 4. ä¸ºæ¨¡å‹æ·»åŠ ä¸“å±å…‰æº
                    addModelSpecificLights(model);

                    // 5. ä¸ºæ¨¡å‹æ·»åŠ åŒ…å›´ç›’ï¼Œç”¨äºé«˜æ•ˆç¢°æ’æ£€æµ‹
                    const boundingBox = new THREE.Box3().setFromObject(model);

                    // 6. å­˜å‚¨æ¨¡å‹å¼•ç”¨å’Œç›¸å…³ä¿¡æ¯
                    const modelInfo = {
                        model: model,
                        modelIndex: modelIndex,
                        position: { x: posX, y: modelY, z: posZ },
                        boundingBox: boundingBox,
                        infoName: null,
                        infoContent: null,
                        infoLoaded: false,
                        lastCheckTime: 0
                    };

                    glbModels.push(modelInfo);

                    // 7. å¼‚æ­¥åŠ è½½ä»‹ç»æ–‡æœ¬
                    loadExhibitInfo(modelIndex)
                        .then(info => {
                            modelInfo.infoName = info.name;
                            modelInfo.infoContent = info.content;
                            modelInfo.infoLoaded = true;
                            console.log(`æ¨¡å‹${modelIndex}ï¼šä»‹ç»æ–‡æœ¬å·²åŠ è½½ - "${info.name}"`);
                        });

                    // 8. æ·»åŠ åˆ°åœºæ™¯
                    scene.add(model);

                    console.log(`æ¨¡å‹${modelIndex}ï¼šå·²åº”ç”¨ç»Ÿä¸€å€¾æ–œ${Math.round(unifiedTiltAngle * 180 / Math.PI)}åº¦`);
                },
                (xhr) => {
                    console.log(`æ¨¡å‹${modelIndex}åŠ è½½è¿›åº¦ï¼š${Math.round((xhr.loaded / xhr.total) * 100)}%`);
                },
                (error) => {
                    console.log(`æ¨¡å‹${modelIndex}æœªæ‰¾åˆ°ï¼Œä½¿ç”¨è“è‰²æ–¹å—å…œåº•`, error);
                    const cube = new THREE.Mesh(exhibitGeo, exhibitMat);
                    cube.position.set(posX, 1.5, posZ);
                    cube.rotation.y = 0;
                    cube.castShadow = true;
                    scene.add(cube);
                }
            );
        }

        // è§’è½è£…é¥°æ–¹å—ï¼ˆä¿æŒåŸæ ·ï¼‰
        const decorGeo = new THREE.BoxGeometry(1.2, 1.2, 1.2);
        const decorMat = new THREE.MeshStandardMaterial({
            color: 0xffcc00,
            roughness: 0.5,
            metalness: 0.2
        });

        const decorPositions = [
            { x: groundBounds.minX + 5, y: 0.6, z: groundBounds.minZ + 5 },
            { x: groundBounds.maxX - 5, y: 0.6, z: groundBounds.minZ + 5 },
            { x: groundBounds.minX + 5, y: 0.6, z: groundBounds.maxZ - 5 },
            { x: groundBounds.maxX - 5, y: 0.6, z: groundBounds.maxZ - 5 }
        ];

        decorPositions.forEach(pos => {
            const decor = new THREE.Mesh(decorGeo, decorMat);
            decor.position.set(pos.x, pos.y, pos.z);
            decor.castShadow = true;
            scene.add(decor);
        });

        // ========== 10. å…‰æºç³»ç»Ÿï¼ˆæ€§èƒ½ä¼˜åŒ–ç‰ˆï¼‰ ==========
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(-15, 40, 30);
        dirLight.castShadow = true;

        // ä¼˜åŒ–é˜´å½±è´¨é‡ä»¥æå‡æ€§èƒ½
        dirLight.shadow.mapSize.width = 1024; // é™ä½é˜´å½±åˆ†è¾¨ç‡
        dirLight.shadow.mapSize.height = 1024;
        dirLight.shadow.camera.near = 1;
        dirLight.shadow.camera.far = 150;
        dirLight.shadow.camera.left = -40;
        dirLight.shadow.camera.right = 40;
        dirLight.shadow.camera.top = 40;
        dirLight.shadow.camera.bottom = -40;

        scene.add(dirLight);

        const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
        fillLight.position.set(20, 30, -20);
        fillLight.castShadow = false; // è¾…åŠ©å…‰ä¸äº§ç”Ÿé˜´å½±
        scene.add(fillLight);

        // ========== æ–°å¢ï¼šä¼˜åŒ–çš„å±•å“ä»‹ç»ç³»ç»Ÿ ==========
        const exhibitInfo = document.getElementById('exhibitInfo');
        const exhibitInfoName = document.getElementById('exhibitInfoName');
        const exhibitInfoContent = document.getElementById('exhibitInfoContent');

        // å°„çº¿æ£€æµ‹å™¨
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(0, 0); // å±å¹•ä¸­å¿ƒ

        // å½“å‰é€‰ä¸­çš„å±•å“
        let currentSelectedModel = null;
        let hideTimer = null;

        // æ€§èƒ½ä¼˜åŒ–ï¼šé™ä½æ£€æµ‹é¢‘ç‡
        let frameCount = 0;
        const CHECK_INTERVAL = 5; // å¢åŠ åˆ°æ¯5å¸§æ£€æµ‹ä¸€æ¬¡
        const MAX_DISTANCE = 25; // æœ€å¤§æ£€æµ‹è·ç¦»å‡å°‘åˆ°25å•ä½

        // æ€§èƒ½ä¼˜åŒ–ï¼šç¼“å­˜ä¸Šæ¬¡æ£€æµ‹ç»“æœ
        let lastIntersectResult = null;
        let lastCheckTime = 0;

        // æ€§èƒ½ä¼˜åŒ–ï¼šä½¿ç”¨çƒå½¢æ£€æµ‹ä»£æ›¿ç²¾ç¡®çš„åŒ…å›´ç›’æ£€æµ‹
        const detectionSpheres = [];

        // æ£€æµ‹å‡†æ˜Ÿæ˜¯å¦å¯¹å‡†å±•å“ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
        function checkExhibitIntersection() {
            // åªåœ¨ç¬¬ä¸€äººç§°è§†è§’ä¸‹æ£€æµ‹
            if (perspectiveMode !== "first") {
                if (currentSelectedModel) {
                    hideExhibitInfo();
                }
                return;
            }

            // æ€§èƒ½ä¼˜åŒ–ï¼šé™ä½æ£€æµ‹é¢‘ç‡
            frameCount++;
            if (frameCount % CHECK_INTERVAL !== 0) {
                return;
            }

            // æ€§èƒ½ä¼˜åŒ–ï¼šå¦‚æœç©å®¶æ²¡æœ‰ç§»åŠ¨ä¸”è§†è§’æ²¡æœ‰å˜åŒ–ï¼Œè·³è¿‡æ£€æµ‹
            const now = Date.now();
            if (currentSelectedModel && now - lastCheckTime < 200) {
                return;
            }
            lastCheckTime = now;

            // è®¾ç½®å°„çº¿èµ·ç‚¹ä¸ºç›¸æœºä½ç½®ï¼Œæ–¹å‘ä¸ºç›¸æœºæœå‘
            raycaster.setFromCamera(mouse, camera);

            // æ€§èƒ½ä¼˜åŒ–ï¼šä½¿ç”¨æ›´é«˜æ•ˆçš„æ£€æµ‹æ–¹æ³•
            let closestIntersection = null;
            let closestDistance = Infinity;

            // åˆ›å»ºæ£€æµ‹ç”¨çš„çƒä½“ï¼ˆå¦‚æœè¿˜æ²¡æœ‰åˆ›å»ºï¼‰
            if (detectionSpheres.length === 0) {
                for (const modelInfo of glbModels) {
                    // ä½¿ç”¨æ›´ç®€å•çš„çƒä½“ç¢°æ’æ£€æµ‹
                    const sphere = new THREE.Sphere();
                    modelInfo.boundingBox.getBoundingSphere(sphere);
                    sphere.radius *= 1.2; // ç¨å¾®æ‰©å¤§ä¸€ç‚¹ï¼Œæ›´å®¹æ˜“é€‰ä¸­
                    detectionSpheres.push({
                        sphere: sphere,
                        modelInfo: modelInfo
                    });
                }
            }

            for (const detectionSphere of detectionSpheres) {
                const modelInfo = detectionSphere.modelInfo;

                // å¿«é€Ÿè·ç¦»æ£€æŸ¥ï¼šå¦‚æœæ¨¡å‹è·ç¦»ç›¸æœºå¤ªè¿œï¼Œè·³è¿‡æ£€æµ‹
                const distanceToCamera = camera.position.distanceTo(
                    new THREE.Vector3(modelInfo.position.x, modelInfo.position.y, modelInfo.position.z)
                );

                // å¦‚æœè·ç¦»è¶…è¿‡æœ€å¤§æ£€æµ‹è·ç¦»ï¼Œè·³è¿‡æ£€æµ‹
                if (distanceToCamera > MAX_DISTANCE) {
                    continue;
                }

                // ä½¿ç”¨çƒä½“è¿›è¡Œå¿«é€Ÿç›¸äº¤æµ‹è¯•ï¼ˆæ¯”åŒ…å›´ç›’å¿«ï¼‰
                const intersectPoint = raycaster.ray.intersectSphere(detectionSphere.sphere, new THREE.Vector3());

                if (intersectPoint) {
                    const distance = intersectPoint.distanceTo(camera.position);
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestIntersection = modelInfo;
                    }
                }
            }

            // å¤„ç†æ£€æµ‹ç»“æœ
            if (closestIntersection && closestIntersection !== currentSelectedModel) {
                // æ¸…é™¤ä¹‹å‰çš„éšè—è®¡æ—¶å™¨
                if (hideTimer) {
                    clearTimeout(hideTimer);
                    hideTimer = null;
                }

                // æ˜¾ç¤ºæ–°å±•å“çš„ä»‹ç»
                currentSelectedModel = closestIntersection;
                showExhibitInfo(currentSelectedModel);

                // ç¼“å­˜ç»“æœ
                lastIntersectResult = closestIntersection;
            } else if (!closestIntersection && currentSelectedModel) {
                // æ²¡æœ‰å¯¹å‡†ä»»ä½•å±•å“ï¼Œä½†ä¹‹å‰æœ‰é€‰ä¸­çš„å±•å“
                if (!hideTimer) {
                    // è®¾ç½®1ç§’åéšè—ä»‹ç»
                    hideTimer = setTimeout(() => {
                        hideExhibitInfo();
                        currentSelectedModel = null;
                        hideTimer = null;
                        lastIntersectResult = null;
                    }, 1000);
                }
            } else if (closestIntersection && closestIntersection === currentSelectedModel) {
                // ä»ç„¶å¯¹å‡†åŒä¸€ä¸ªå±•å“ï¼Œé‡ç½®éšè—è®¡æ—¶å™¨
                if (hideTimer) {
                    clearTimeout(hideTimer);
                    hideTimer = null;
                }
            }
        }

        // æ˜¾ç¤ºå±•å“ä»‹ç»
        function showExhibitInfo(modelInfo) {
            if (!modelInfo.infoLoaded) {
                exhibitInfoName.textContent = `å±•å“ ${modelInfo.modelIndex}`;
                exhibitInfoContent.textContent = "ä»‹ç»æ­£åœ¨åŠ è½½ä¸­...";
            } else {
                exhibitInfoName.textContent = modelInfo.infoName;
                exhibitInfoContent.textContent = modelInfo.infoContent;
            }

            exhibitInfo.classList.add('show');
        }

        // éšè—å±•å“ä»‹ç»
        function hideExhibitInfo() {
            exhibitInfo.classList.remove('show');
        }

        // ========== 11. åŠ¨ç”»å¾ªç¯ï¼ˆæ€§èƒ½ä¼˜åŒ–ç‰ˆï¼‰ ==========
        let lastTime = 0;
        const fpsLimit = 60; // é™åˆ¶å¸§ç‡
        const frameTime = 1000 / fpsLimit;

        function animate(currentTime) {
            requestAnimationFrame(animate);

            // é™åˆ¶å¸§ç‡ä»¥æé«˜æ€§èƒ½
            const deltaTime = currentTime - lastTime;
            if (deltaTime < frameTime) {
                return;
            }
            lastTime = currentTime - (deltaTime % frameTime);

            updatePlayerMovement();
            updateCamera();

            // æ£€æŸ¥å‡†æ˜Ÿæ˜¯å¦å¯¹å‡†å±•å“ï¼ˆå·²ä¼˜åŒ–é¢‘ç‡ï¼‰
            checkExhibitIntersection();

            renderer.render(scene, camera);
        }
        requestAnimationFrame(animate);

        // ========== 12. çª—å£è‡ªé€‚åº” ==========
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ========== 13. åˆå§‹åŒ– ==========
        // åˆå§‹åŒ–èƒŒæ™¯éŸ³ä¹ç³»ç»Ÿ
        initBackgroundMusic();

        updateCamera();

        console.log("âœ… å±•å…å·²å¯åŠ¨ï¼ˆä¼˜åŒ–ç‰ˆäººç‰©æ¨¡å‹ï¼‰ï¼š");
        console.log("ğŸ“Š æ€§èƒ½ä¼˜åŒ–è®¾ç½®ï¼š");
        console.log("  - åƒç´ æ¯”å›ºå®š: 1.0");
        console.log("  - æŠ—é”¯é½¿: å…³é—­");
        console.log("  - æ¸²æŸ“ç²¾åº¦: lowp");
        console.log("  - æ£€æµ‹é¢‘ç‡: æ¯5å¸§æ£€æµ‹ä¸€æ¬¡");
        console.log("  - æœ€å¤§æ£€æµ‹è·ç¦»: " + MAX_DISTANCE + "å•ä½");
        console.log("  - å¸§ç‡é™åˆ¶: " + fpsLimit + "FPS");
        console.log("  - é˜´å½±åˆ†è¾¨ç‡: 1024x1024");
        console.log("ğŸµ èƒŒæ™¯éŸ³ä¹ç³»ç»Ÿï¼š");
        console.log("  - éŸ³ä¹æ–‡ä»¶å¤¹: " + musicFolder);
        console.log("  - è‡ªåŠ¨æ’­æ”¾: æ˜¯ï¼ˆéœ€è¦ç”¨æˆ·äº¤äº’åï¼‰");
        console.log("  - å¾ªç¯æ’­æ”¾: æ˜¯");
        console.log("  - éŸ³é‡: 50%");
        console.log("ğŸ‘¤ äººç‰©æ¨¡å‹è®¾ç½®ï¼š");
        console.log("  - æ¨¡å‹æ–‡ä»¶: 3d_models/character.glb");
        console.log("  - æ¨¡å‹é«˜åº¦: -0.3ï¼ˆç¦»åœ°é¢è·ç¦»ï¼‰");
        console.log("  - æ¨¡å‹æ—‹è½¬: 180åº¦");
        console.log("  - ç¬¬ä¸€äººç§°è§†è§’: éšè—äººç‰©æ¨¡å‹");
        console.log("  - ç¬¬ä¸‰äººç§°è§†è§’: æ˜¾ç¤ºäººç‰©æ¨¡å‹");
        console.log("  - è‡ªå‘å…‰å¼ºåº¦: 0.3");
        console.log("  - é˜´å½±: ç¦ç”¨ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼‰");
        console.log("ğŸ“Š æ¨¡å‹å¢å¼ºå‚æ•°ï¼š");
        console.log("  - è‡ªå‘å…‰å¼ºåº¦: " + modelEmissiveIntensity);
        console.log("  - æè´¨äº®åº¦æå‡: " + modelBrightnessBoost + "å€");
        console.log("  - æ‰€æœ‰æ¨¡å‹ç»Ÿä¸€å€¾æ–œè§’åº¦: " + Math.round(unifiedTiltAngle * 180 / Math.PI) + "åº¦");
        console.log("  - æ¯ä¸ªæ¨¡å‹æœ‰ä¸“å±å…‰æº");
        console.log("  - å±•å“ä»‹ç»åŠŸèƒ½å·²å¯ç”¨ï¼ˆä»…ç¬¬ä¸€äººç§°è§†è§’ï¼Œå·²ä¼˜åŒ–æ€§èƒ½ï¼‰");
        console.log("  - ä»‹ç»æ–‡æœ¬è·¯å¾„: " + introductionFolder + "/");
        console.log("  - TXTæ ¼å¼: ç¬¬ä¸€è¡Œä¸ºå±•å“åç§°ï¼Œå‰©ä½™ä¸ºä»‹ç»å†…å®¹");
    </script>
</body>
</html>

